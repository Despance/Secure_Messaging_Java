import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class MasterSecret {

    private static final String ALGORITHM = "HmacSHA256";
    private static final int MASTER_SECRET_LENGTH = 48; // 48 bytes for the master secret
    private static final byte[] label = "master secret".getBytes(); // Label for the master secret
    
    private byte[] masterSecret;

    //TODO: could make it a static class instead
    //TODO: should we use a static label or should we pass it as a parameter which we get from the handshake?
    
    public MasterSecret() {
        this.masterSecret = new byte[MASTER_SECRET_LENGTH];
    }

    private void generateMasterSecret(byte[] preMasterSecret, byte[] clientNonce, byte[] serverNonce) {
        try {
            Mac hmac = Mac.getInstance(ALGORITHM);
            SecretKeySpec keySpec = new SecretKeySpec(preMasterSecret, ALGORITHM);
            hmac.init(keySpec);

            byte[] seed = new byte[label.length + clientNonce.length + serverNonce.length];
            seed = (label.toString() + clientNonce.toString() + serverNonce.toString()).getBytes();
            

            byte[] A = seed;
            byte[] result = new byte[MASTER_SECRET_LENGTH];
            int index = 0;
            while(index < MASTER_SECRET_LENGTH){
                // dofinal method resets the internal state of the hmac to its intial state which is our premaster secret
                A = hmac.doFinal(A); // A(i+1) = HMAC(secret, A(i))
                byte[] temp = hmac.doFinal((A.toString()+seed.toString()).getBytes()); // HMAC(secret, A(i)+seed)
                
                int length = Math.min(MASTER_SECRET_LENGTH - index, temp.length);
                System.arraycopy(temp, 0, result, index, length); // Copy the generated bytes to the result(master secret) without passing the length limit
                index += length;
            }
            this.masterSecret = result; // Set the generated master secret

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public byte[] getMasterSecret(byte[] preMasterSecret, byte[] clientNonce, byte[] serverNonce) {
        generateMasterSecret(preMasterSecret, clientNonce, serverNonce);
        return masterSecret;
    }
    
}
