import java.security.SecureRandom;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class KeyGenerationHelper {

    private static final String ALGORITHM = "HmacSHA256";
    private static final int MASTER_SECRET_LENGTH = 48; // 48 bytes as stated in rfc 7627
    private static final int PREMASTER_SECRET_LENGTH = 48; // 48 bytes as stated in rfc5246
    // 32(aes256 client) + 32(sha256 client) + 32(aes256 server) + 32(sha256 server)
    private static final int KEY_GEN_LENGTH = 128; // TODO: need to add 64 more bits for IV (32 each) if we choose to use cbc
        

    // prf(pseudo random function) as stated in rfc 5246
    private static byte[] Prf(byte[] secret, byte[] seed, String label, int length) {
        try {
            Mac hmac = Mac.getInstance(ALGORITHM);
            SecretKeySpec keySpec = new SecretKeySpec(secret, ALGORITHM);
            hmac.init(keySpec);

            byte[] A = seed;
            byte[] result = new byte[length];
            int currentLength = 0;
            for(int i = 0; i < length; i += currentLength){
                // dofinal method resets the internal state of the hmac to its intial state which is our premaster secret
                A = hmac.doFinal(A); // A(i+1) = HMAC(secret, A(i))
                byte[] temp = hmac.doFinal(concatBytes(A, seed)); // HMAC(secret, A(i)+seed)
                
                currentLength = Math.min(length - i, temp.length);
                System.arraycopy(temp, 0, result, i, currentLength); // Copy the generated bytes to the result(master secret) without passing the length limit
                
            }
            return result; // Set the generated master secret

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
    
    private static byte[] concatBytes(byte[] a, byte[] b){
        byte[] result = new byte[a.length + b.length];
        System.arraycopy(a, 0, result, 0, a.length);
        System.arraycopy(b, 0, result, a.length, b.length);
        return result;
    }

    public static byte[] generateMasterSecret(byte[] premasterSecret, byte[] clientNonce, byte[] serverNonce){
        // apparently the lablel is "master secret" which kind of sounds dumb but it is stated in the RFC 7627 as such... yeah
        return Prf(premasterSecret, concatBytes(clientNonce, serverNonce), "master secret", MASTER_SECRET_LENGTH);
    }


    public static Keys generateKeys(byte[] masterSecret, byte[] clientNonce, byte[] serverNonce){
        // apparently the lablel is "key expansion" which kind of sounds dumb but it is stated in the RFC 5246 as such... yeah
        byte[] result = Prf(masterSecret, concatBytes(clientNonce, serverNonce), "key expansion", KEY_GEN_LENGTH);
        byte[] clientMacKey = new byte[32];
        byte[] serverMacKey = new byte[32];
        byte[] clientKey = new byte[32];
        byte[] serverKey = new byte[32];
        System.arraycopy(result, 0, clientMacKey, 0, 32);
        System.arraycopy(result, 32, serverMacKey, 0, 32);
        System.arraycopy(result, 64, clientKey, 0, 32);
        System.arraycopy(result, 96, serverKey, 0, 32);
        return new Keys(clientMacKey, serverMacKey, clientKey, serverKey);
    }

    public static byte[] generatePremasterSecret(){
        byte[] premasterSecret = new byte[PREMASTER_SECRET_LENGTH];
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(premasterSecret);
        
        return premasterSecret;
    }
    
    
}
