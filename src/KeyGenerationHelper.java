import java.security.SecureRandom;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class KeyGenerationHelper {

    private final String ALGORITHM = "HmacSHA256";
    private final int MASTER_SECRET_LENGTH = 48; // 48 bytes as stated in rfc 7627
    private final int PREMASTER_SECRET_LENGTH = 48; // 48 bytes as stated in rfc5246
    // 32(aes256 client) + 32(sha256 client) + 32(aes256 server) + 32(sha256 server)
    // + 16(clien iv) + 16(server iv) = 160
    private final int KEY_GEN_LENGTH = 160;

    private byte[] clientNonce;
    private byte[] serverNonce;
    private byte[] premasterSecret;
    private byte[] masterSecret;

    public KeyGenerationHelper(byte[] clientNonce, byte[] serverNonce) {
        this.clientNonce = clientNonce;
        this.serverNonce = serverNonce;
    }

    public KeyGenerationHelper(byte[] clientNonce, byte[] serverNonce, byte[] premasterSecret) {
        this.clientNonce = clientNonce;
        this.serverNonce = serverNonce;
        this.premasterSecret = premasterSecret;
    }

    // prf(pseudo random function) as stated in rfc 5246
    private byte[] Prf(byte[] secret, byte[] seed, String label, int length) {
        try {
            Mac hmac = Mac.getInstance(ALGORITHM);
            SecretKeySpec keySpec = new SecretKeySpec(secret, ALGORITHM);
            hmac.init(keySpec);

            byte[] A = seed;
            byte[] result = new byte[length];
            int currentIndex = 0;
            while (currentIndex < length) {
                // dofinal method resets the internal state of the hmac to its intial state
                // which is our premaster secret
                A = hmac.doFinal(A); // A(i+1) = HMAC(secret, A(i))
                byte[] temp = hmac.doFinal(concatBytes(A, seed)); // HMAC(secret, A(i)+seed)

                int bytesToCpy = Math.min(length - currentIndex, temp.length);
                System.arraycopy(temp, 0, result, currentIndex, bytesToCpy); // Copy the generated bytes to the
                                                                             // result(master secret) without passing
                                                                             // the length limit
                currentIndex += bytesToCpy;
            }
            return result; // Set the generated master secret

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private byte[] concatBytes(byte[] a, byte[] b) {
        byte[] result = new byte[a.length + b.length];
        System.arraycopy(a, 0, result, 0, a.length);
        System.arraycopy(b, 0, result, a.length, b.length);
        return result;
    }

    private void generateMasterSecret() {
        // apparently the lablel is "master secret" which kind of sounds dumb but it is
        // stated in the RFC 7627 as such... yeah
        masterSecret = Prf(premasterSecret, concatBytes(clientNonce, serverNonce), "master secret",
                MASTER_SECRET_LENGTH);
    }

    private void updateMasterSecret() {
        // couldn't really find anything about using prf for updating keys(may have
        // missed it) so i just used "key update" as the label
        // .... hope that's fine
        masterSecret = Prf(masterSecret, concatBytes(clientNonce, serverNonce), "key update", MASTER_SECRET_LENGTH);
    }

    private Keys generateKeys() {
        // apparently the lablel is "key expansion" which kind of sounds dumb but it is
        // stated in the RFC 5246 as such... yeah
        byte[] result = Prf(masterSecret, concatBytes(clientNonce, serverNonce), "key expansion", KEY_GEN_LENGTH);
        byte[] clientMacKey = new byte[32];
        byte[] serverMacKey = new byte[32];
        byte[] clientKey = new byte[32];
        byte[] serverKey = new byte[32];
        byte[] clientIv = new byte[16];
        byte[] serverIv = new byte[16];
        System.arraycopy(result, 0, clientMacKey, 0, 32);
        System.arraycopy(result, 32, serverMacKey, 0, 32);
        System.arraycopy(result, 64, clientKey, 0, 32);
        System.arraycopy(result, 96, serverKey, 0, 32);
        System.arraycopy(result, 128, clientIv, 0, 16);
        System.arraycopy(result, 144, serverIv, 0, 16);
        return new Keys(clientMacKey, serverMacKey, clientKey, serverKey, clientIv, serverIv);
    }

    public Keys updateKeys() {
        Logg.getLogger().info("Updating keys");

        updateMasterSecret();

        Keys keys = generateKeys();

        Logg.getLogger().info("new keys: " + keys.toString());
        return keys;
    }

    public Keys generateNewKeys() {
        generateMasterSecret();
        return generateKeys();
    }

    public byte[] generateNewPremasterSecret() {
        premasterSecret = new byte[PREMASTER_SECRET_LENGTH];
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(premasterSecret);

        return premasterSecret;
    }

}
